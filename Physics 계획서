 ---

  최종 계획서: Box2D 물리 엔진 통합 (Application 관리 PhysicsManager 포함)

  목표: GNEngine에 Box2D 물리 라이브러리를 통합하여, 엔티티가 물리 법칙에 따라 상호작용할 수 있는 기반을 마련합니다. 기존 ECS/DOD 구조를 유지하며 확장성과 명확성을 확보하는 데 중점을 둡니다.

  이름 결정:
   * 컴포넌트: `RigidBodyComponent`
       * 선택 이유: '강체(Rigid Body)'는 물리 엔진에서 변형되지 않는 객체를 의미하는 표준 용어입니다. PhysicsComponent보다 구체적이어서, 이 컴포넌트가 강체 물리 시뮬레이션용 데이터임을 명확히 나타냅니다. 이는 향후 유체나
         연체(Soft Body) 물리 컴포넌트를 추가할 경우에도 혼동을 방지합니다.
   * 시스템: `PhysicsSystem`
       * 선택 이유: 물리 시뮬레이션 전체를 담당하는 시스템의 역할을 가장 직관적으로 설명하는 이름입니다.
   * 매니저: `PhysicsManager`
       * 선택 이유: 물리 시스템 전반에 걸친 전역 설정, 유틸리티 함수, 그리고 잠재적인 물리 관련 리소스 관리를 담당하는 관리자 역할을 명확히 합니다.

  ---

  1단계: 프로젝트 구조 설정 및 빌드 시스템 연동

  이 단계에서는 실제 코드를 채우기 전에 필요한 모든 파일을 생성하고, 프로젝트가 이들을 인식하여 컴파일할 수 있도록 설정합니다.

   * 1-1. `RigidBodyComponent` 헤더 파일 생성
       * 경로: include/GNEngine/component/RigidBodyComponent.h
       * 목적: 엔티티의 물리적 속성(질량, 마찰력, 형태, 타입 등)을 정의하는 데이터 구조를 선언합니다.

   * 1-2. `PhysicsSystem` 헤더 및 소스 파일 생성
       * 경로:
           * include/GNEngine/system/PhysicsSystem.h
           * src/GNEngine/system/PhysicsSystem.cpp
       * 목적: Box2D의 b2World를 관리하고, 물리 시뮬레이션을 진행하며, 그 결과를 TransformComponent에 반영하는 로직을 구현할 틀을 마련합니다.

   * 1-3. `PhysicsManager` 헤더 및 소스 파일 생성
       * 경로:
           * include/GNEngine/manager/PhysicsManager.h
           * src/GNEngine/manager/PhysicsManager.cpp
       * 목적: 물리 시스템의 전역 설정(예: 중력), 유틸리티 함수, 그리고 향후 확장될 물리 관련 리소스 관리를 담당할 매니저 클래스를 정의합니다.

   * 1-4. CMake 빌드 스크립트 수정
       * 대상: include/GNEngine/CMakeLists.txt, src/GNEngine/CMakeLists.txt
       * 작업: target_sources()에 위에서 생성한 모든 파일(RigidBodyComponent.h, PhysicsSystem.h, PhysicsSystem.cpp, PhysicsManager.h, PhysicsManager.cpp)들을 추가하여 GNEngine 라이브러리에 포함시킵니다.

   * 1-5. Box2D 라이브러리 연결
       * 대상: CMakeLists.txt (최상위 또는 라이브러리 링크 담당 파일)
       * 작업: find_package(Box2D REQUIRED)를 통해 라이브러리를 찾고, target_link_libraries()를 사용하여 GNEngine이 Box2D와 링크되도록 설정합니다. 이를 통해 Box2D의 함수들을 코드에서 사용할 수 있게 됩니다.

  ---

  2단계: `RigidBodyComponent` 상세 구현

  물리 객체의 '설계도' 역할을 할 컴포넌트의 내부를 구체적으로 정의합니다.

   * 2-1. 멤버 변수 정의 (`RigidBodyComponent.h`)
       * b2Body* runtimeBody: PhysicsSystem에 의해 생성된 실제 Box2D 객체를 가리킬 포인터.
       * glm::vec2 size: 물리적 몸체의 크기 (너비, 높이).
       * b2BodyType bodyType: b2_staticBody(고정), b2_kinematicBody(코드 제어), b2_dynamicBody(물리 제어) 중 하나.
       * float density, float friction, float restitution: 각각 밀도, 마찰 계수, 반발 계수.
       * bool fixedRotation: 회전 여부. 캐릭터 컨트롤 등에 유용합니다.

   * 2-2. 주석 작성
       * 프로젝트 규칙에 따라 각 멤버 변수의 역할과 @param 형식의 생성자 파라미터 설명을 상세히 기술합니다.

  ---

  3단계: `PhysicsManager` 상세 구현

  물리 시스템의 전역 설정과 유틸리티 기능을 제공합니다. Application에서 직접 인스턴스화하여 관리합니다.

   * 3-1. 멤버 변수 정의 (`PhysicsManager.h`)
       * b2Vec2 gravity: 물리 세계의 중력 벡터를 정의합니다. (예: b2Vec2(0.0f, 9.8f))
       * float pixelsPerMeter: 엔진의 픽셀 단위와 Box2D의 미터 단위를 변환하기 위한 스케일 팩터. (예: 32.0f)
       * float timeStep: 물리 시뮬레이션의 고정 시간 간격 (예: 1.0f / 60.0f).

   * 3-2. 유틸리티 함수 (선택적, 향후 확장)
       * 픽셀-미터 변환 함수 (pixelsToMeters, metersToPixels).
       * 향후 충돌 필터링, 디버그 드로잉 설정 등 전역적으로 관리될 기능들을 추가할 수 있습니다.

  ---

  4단계: `PhysicsSystem` 상세 구현

  GNEngine의 데이터와 Box2D의 시뮬레이션을 연결하는 핵심 로직을 구현합니다. PhysicsManager 인스턴스를 주입받아 전역 설정을 사용합니다.

   * 4-1. 생성자 또는 `init` 메서드 수정
       * PhysicsManager 인스턴스에 대한 참조 또는 포인터를 매개변수로 받도록 수정합니다. 이를 통해 PhysicsSystem은 PhysicsManager의 전역 설정에 접근할 수 있습니다.

   * 4-2. 초기화 로직 구현 (`init`)
       * 주입받은 PhysicsManager 인스턴스로부터 중력 값을 가져와 b2World 객체를 생성합니다.
       * EntityManager로부터 RigidBodyComponent와 TransformComponent를 모두 가진 엔티티 목록을 가져옵니다.
       * 각 엔티티에 대해 RigidBodyComponent의 데이터와 TransformComponent의 위치를 기반으로 b2Body를 생성합니다. 이때 PhysicsManager의 pixelsPerMeter를 사용하여 좌표를 변환합니다.
       * 생성된 b2Body 포인터를 RigidBodyComponent의 runtimeBody에 저장합니다.

   * 4-3. 업데이트 로직 구현 (`update`)
       * 주입받은 PhysicsManager 인스턴스로부터 timeStep을 가져와 b2World::Step()을 호출하여 한 프레임만큼의 물리 시뮬레이션을 실행합니다.
       * b2_dynamicBody 타입의 엔티티들을 대상으로, 시뮬레이션 결과로 나온 새로운 위치(GetPosition)와 회전(GetAngle) 값을 가져옵니다.
       * 가져온 값을 해당 엔티티의 TransformComponent에 갱신합니다. 이때 PhysicsManager의 pixelsPerMeter를 사용하여 좌표를 다시 픽셀 단위로 변환합니다.

   * 4-4. 자원 해제 로직 구현 (`shutdown`)
       * b2World 객체를 소멸시켜, 생성된 모든 b2Body와 관련 메모리를 안전하게 해제합니다. (주로 std::unique_ptr을 통한 RAII로 자동화)

  ---

  5단계: 최종 통합 및 검증

  구현된 물리 시스템을 실제 엔진에 탑재하고, 예제 프로젝트를 통해 정상적으로 작동하는지 확인합니다.

   * 5-1. `example/T.C.S/Application` 클래스 수정
       * Application 클래스 내부에 PhysicsManager 멤버 변수를 선언하고 인스턴스화합니다.
       * Application::init()에서 PhysicsManager를 초기화합니다.
       * PhysicsSystem을 생성할 때, 이 PhysicsManager 인스턴스를 PhysicsSystem의 생성자 또는 init 메서드에 전달합니다.

   * 5-2. 엔진 코어 등록 (`Application::init`)
       * EntityManager와 SystemManager에 각각 RigidBodyComponent와 PhysicsSystem을 등록하여 엔진이 인식하도록 합니다.

   * 5-4. 씬 구성
    
  ---